# Тестування на включення локального файлу

## Огляд

Уразливість File Inclusion дозволяє зловмиснику включити файл, зазвичай використовуючи механізми «динамічного включення файлу», реалізовані в цільовій програмі. Уразливість виникає через використання введених користувачем даних без належної перевірки.

Це може призвести до чогось схожого на виведення вмісту файлу, але залежно від серйозності це також може призвести до:

* Виконання коду на веб-сервері
* Виконання коду на стороні клієнта, наприклад JavaScript, що може призвести до інших атак, наприклад міжсайтового сценарію (XSS)
* Відмова в обслуговуванні (DoS)
* Розкриття конфіденційної інформації

Включення локальних файлів (також відоме як LFI) — це процес включення файлів, які вже локально присутні на сервері, шляхом використання вразливих процедур включення, реалізованих у програмі. Ця вразливість виникає, наприклад, коли сторінка отримує як вхідні дані шлях до файлу, який потрібно включити, і цей вхід не очищається належним чином, що дозволяє вставляти символи обходу каталогу (наприклад, крапка-крапка-коса риска). Хоча більшість прикладів вказують на вразливі сценарії PHP, ми повинні мати на увазі, що це також поширене в інших технологіях, таких як JSP, ASP та інші.

## Як тестувати

Оскільки LFI виникає, коли шляхи, **передані операторам включення**, не очищаються належним чином, у підході до тестування чорної скриньки нам слід шукати сценарії, які приймають імена файлів як параметри.

Розглянемо такий приклад:

**http://vulnerable_host/preview.php?file=example.html**

Це виглядає як ідеальне місце, щоб спробувати LFI. Якщо зловмиснику пощастить, і замість вибору відповідної сторінки з масиву за її іменем, сценарій безпосередньо включає вхідний параметр, можна включити довільні файли на сервері.

Типовим підтвердженням концепції було б завантажити файл passwd:

**http://vulnerable_host/preview.php?file=../../../../etc/passwd**

Якщо зазначені вище умови виконуються, зловмисник побачить приблизно таке:


    root:x:0:0:root:/root:/bin/bash
    bin:x:1:1:bin:/bin:/sbin/nologin
    daemon:x:2:2:daemon:/sbin:/sbin/nologin
    alex:x:500:500:alex:/home/alex:/bin/bash
    margo:x:501:501::/home/margo:/bin/bash
    ...

Навіть якщо така вразливість існує, її використання може бути більш складним у реальних сценаріях. Розглянемо такий фрагмент коду:

**<?php include($_GET['file'].".php"); ?>**

Проста заміна на випадкову назву файлу не спрацює, оскільки постфікс **.php** додається до наданого введення. Щоб обійти його, тестер може використовувати кілька методів, щоб отримати очікувану експлуатацію.

## Ін'єкція нульового байта

**Нульовий символ** (також відомий як **нульовий термінатор** або **нульовий байт**) — це керуючий символ зі значенням нуль, присутній у багатьох наборах символів, який використовується як зарезервований символ для позначення кінця рядка. Після використання будь-який символ після цього спеціального байту ігноруватиметься. Зазвичай цей символ можна додати за допомогою рядка **%00** у кодуванні URL-адреси, додавши його до запитаного шляху. У нашому попередньому прикладі виконання запиту до **http://vulnerable_host/preview.php?file=../../../../etc/passwd%00** ігноруватиме розширення **.php**, додане до імені вхідного файлу , повертаючи зловмиснику список базових користувачів у результаті успішної експлуатації.

## Обрізання шляхів та крапок

Більшість установок PHP мають обмеження на ім’я файлу 4096 байт. Якщо будь-яке ім’я файлу перевищує цю довжину, PHP просто скорочує його, відкидаючи всі додаткові символи. Зловживання такою поведінкою дає змогу змусити механізм PHP ігнорувати розширення **.php**, перемістивши його за межі 4096 байтів. Коли це відбувається, помилка не виникає; додаткові символи просто видаляються, і PHP продовжує своє виконання в звичайному режимі.

Цей обхід зазвичай поєднується з іншими стратегіями логічного обходу, такими як кодування частини шляху до файлу за допомогою кодування Unicode, введення подвійного кодування або будь-який інший вхід, який все ще представлятиме дійсне бажане ім’я файлу.

## Обгортки PHP

Уразливості включення локальних файлів зазвичай розглядаються як уразливості лише для читання, які зловмисник може використовувати для читання конфіденційних даних із сервера, на якому розміщено вразливу програму. Однак у деяких конкретних реалізаціях цю вразливість можна використовувати для оновлення атаки з LFI на вразливості Remote Code Execution, які потенційно можуть повністю скомпрометувати хост.

Це покращення є звичайним, коли зловмисник може поєднати вразливість LFI з певними оболонками PHP.

Обгортка — це код, який оточує інший код для виконання деяких додаткових функцій. PHP реалізує багато вбудованих оболонок для використання з функціями файлової системи. Якщо під час тестування програми буде виявлено їх використання, доцільно спробувати зловживати ним, щоб визначити реальний ризик виявлених недоліків. Нижче ви можете отримати список із найбільш часто використовуваними обгортками, хоча ви повинні враховувати, що він не є вичерпним і в той же час можна зареєструвати

### Фільтр PHP

Використовується для доступу до локальної файлової системи; це нечутлива до регістру оболонка, яка надає можливість застосовувати фільтри до потоку під час відкриття файлу. Ця оболонка може бути використана для отримання вмісту файлу, що заважає серверу виконати його. Наприклад, дозволити зловмиснику прочитати вміст PHP-файлів, щоб отримати вихідний код для ідентифікації конфіденційної інформації, такої як облікові дані або інші вразливості, які можна використовувати.

Обгортку можна використовувати як **php://filter/convert.base64-encode/resource=FILE**, де **FILE** — це файл, який потрібно отримати. У результаті використання цього виконання вміст цільового файлу буде прочитано, закодовано в base64 (це крок, який запобігає виконанню на стороні сервера) і повернуто агенту користувача.

### PHP ZIP

У PHP 7.2.0 було введено оболонку **zip://** для роботи зі стиснутими файлами **zip**. Ця оболонка передбачає таку структуру параметрів: **zip:///шлях до_файлу#внутрішня_ім'я_файлу, де шлях до_файлу** — це шлях до зловмисного файлу, а **внутрішнє_ім'я_файлу** — це шлях, де зловмисний файл розміщено всередині обробленого ZIP-файлу. Під час експлуатації зазвичай **#** буде закодовано зі своїм URL-кодованим значенням **%23**.

Зловживання цією оболонкою може дозволити зловмиснику створити шкідливий ZIP-файл, який можна буде завантажити на сервер, наприклад, як зображення аватара або за допомогою будь-якої системи завантаження файлів, доступної на цільовому веб-сайті (обгортка **php:zip://** не вимагати, щоб zip-файл мав будь-яке конкретне розширення) для виконання вразливістю LFI.

Щоб перевірити цю вразливість, можна виконати наведену нижче процедуру для атаки на наданий попередній приклад коду.

1. Створіть файл PHP для виконання, наприклад із вмістом **<?php phpinfo(); ?>** і збережіть його як **code.php**
2. Стисніть його як новий ZIP-файл під назвою **target.zip**
3. Перейменуйте файл **target.zip** на **target.jpg**, щоб обійти перевірку розширення та завантажити його на цільовий веб-сайт як зображення аватара.
4. Припустимо, що файл **target.jpg** зберігається локально на сервері за шляхом **../avatar/target.jpg**, скористайтеся уразливістю за допомогою обгортки PHP ZIP, вставивши таке корисне навантаження до вразливої URL-адреси: **zip://../ avatar/target.jpg%23code** (пам’ятайте, що **%23** відповідає **#**).

Оскільки в нашому зразку розширення **.php** об’єднано з нашим корисним навантаженням, запит до **http://vulnerable_host/preview.php?file=zip://../avatar/target.jpg%23code** призведе до виконання **code.php**, наявний у шкідливому ZIP-файлі.

### Дані PHP

Ця оболонка, доступна з PHP 5.2.0, передбачає таке використання: **data://text/plain;base64,BASE64_STR**, де **BASE64_STR** має бути закодованим у Base64 вмістом файлу для обробки. Важливо враховувати, що ця обгортка буде доступною, лише якщо буде ввімкнено параметр **allow_url_include**.

Щоб перевірити LFI за допомогою цієї обгортки, код, який буде виконано, має мати кодування Base64, наприклад, **<?php phpinfo(); ?>** код буде закодовано так: **PD9waHAgcGhwaW5mbygpOyA/Pg==**, тому корисне навантаження матиме вигляд: **data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==**.

### PHP Expect

Ця оболонка, яка не ввімкнена за замовчуванням, забезпечує доступ до процесів **stdio**, **stdout** і **stderr**. Очікуючи, що його буде використано як **expect://command**, сервер виконає надану команду на **BASH** і поверне її результат.

## Рішення

Найефективнішим рішенням для усунення вразливості включення файлів є уникнення передачі даних, наданих користувачем, будь-якій файловій системі/фреймворку API. Якщо це неможливо, програма може підтримувати дозволений список файлів, які можуть бути включені сторінкою, а потім використовувати ідентифікатор (наприклад, номер індексу) для доступу до вибраного файлу. Будь-який запит, що містить недійсний ідентифікатор, має бути відхилений, таким чином зловмисники не мають можливості маніпулювати шляхом атаки.
